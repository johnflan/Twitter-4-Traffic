Management of source-code, documentation and binary files can be tedious for an individual, but when you consider a team working on a set of files, tracking changes and version becomes close to impossible.

The concept of source code management dates back to 1972\cite{website:catb_org} with the “Source Code Control System” running in the IBM mainframe environment. Today numerous commercial and free revision control systems are in everyday usage. While many different approaches are used for tracking files, all systems offer similar basic functionality. This main functionality could be described under the title ‘collaboration’, enabling multiple individuals to work on as set of files while ensuring changes don’t get lost and enabling tracking of versions. However, modern systems offer powerful features such as verifiable histories, ability to integrate with deployment, test and code review systems and the ability to add rules to enforce corporate policy and process.

Of the options available, the chosen system had to satisfy a number of requirements. The system had to be free and preferably open-source, work well in a disconnected environment, have good documentation and also beneficial if this tool is in common use. Git\cite{website:git_scm}, the open-source distributed revision control system used by many major projects including the Linux Kernel, Google’s Android, Eclipse and Ruby on Rails seemed to meet the teams requirements. Additionally a number of team members have previous experience using the tool, which will lessen the initial learning curve.

The distributed nature of Git means a centralised ‘server’ is not necessary, but for convenience Github\cite{website:github} an online hosting service for git is being utilised. In addition to simply hosting the repository, Github offers a simple user interface for browsing the history, project bug-tracking and wiki for documentation, and is free for public projects with less the 300mb of history. There is however a downside to using Github, we lose the ability to write scripts to interface with the git hooks framework (on the server). Git hooks enable scripts to be executed when actions such as commits are performed. This can be useful for executing test cases, sending emails to notify of a commit and various other actions.

From the beginning of the project it was agreed that all data will exist outside of the repository. This was enforced initially by creating a defined directory structure for the repository and secondly by creating a ‘.gitignore’ file in the root of the repository to list file types to be not tracked by default. Also, we are actively pursuing the concept of code-review where by every commit must be reviewed by at least one other team member. 

It is important for that team that using a revision control system helps make the development easier. To this end we are attempting to make our commit messages as concise and descriptive as possible. The book Pro Git\cite{website:pro_git_ch2} describes a good commit as the following; break the message into a brief 50 character summary and followed by a more detailed description. This more detailed description should contrast the new functionally with any previous functionality and describe the motivation for the change set. Enforcing good commit messages will help any team member to quickly look at the commit log and understand the current state of development. With this it is also important to not get too wrapped up in the process, and keep the development somewhat agile.

The team’s repository is available at: \url{https://github.com/johnflan/Twitter-4-Traffic}
\pagebreak 
